
<!DOCTYPE html>
<html>
  <head>
    <title>Wodan: persistence for Mirage</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Wodan

## Persistence for Mirage

---
# Goals and non-goals

## Goals

- Provide a toolkit
- Tunable, efficient implementation
- Integrity: fsck is not a separate utility, every loaded block has been checked
- Resilience to flaky storage: checksumming
- Give control to the upper layers
- Portability: Unix and Unikernels
- Be the base building block for Mirage persistence

---
# Goals and non-goals

## Non-goals

- No DWIM: you have to know what you want
- Costly operations have to be called explicitly
  - flushing, bulk discard never implied
- No one-size-fits-all
  - pick a block size that fits your underlying device
  - pick a key size that fits your application (integers? SHA?)
- No stable format: dump and restore if necessary
- No POSIX compatibility: do one thing well
- No types, no text, just binary values

---
# What can you do with a key-value store?

- Content-addressed storage (similar to Git or IPFS)
- All the Irmin primitives
- RO: read-only
- AO: append-only — content-addressed, keys derived from values
- RW: updateable — hashed key to payload
- Also enumerable (list of keys, expected to be small) and watchable (notify)

---
# What can you do on top of RO/AO/RW?

- The feature set of Irmin or Git
- Distribution
- Merging
- Transactions
- Sync

---
# Providing a block device

Currently we extend the standard Mirage signature

Stubs are fine, and provided.

```ocaml
(let) module Block = Wodan.BlockCompat(Block) (in)
```

---
# Configuring the store

```ocaml
module Stor = Wodan.Make(Block)(struct
  include Wodan.StandardSuperblockParams

  let key_size = 20
  let block_size = 256*1024
end)
```

Note:
These defaults have very large fanout, and are appropriate for
infrequent flushing or SSDs with large erase blocks.

---
# Creating an image

```bash
touch wodan.img
fallocate -l16M -z wodan.img
wodanc format wodan.img
```

---
# Dumping and loading data

```bash
wodanc dump wodan.img > dump.tsv
wodanc restore wodan.img < dump.tsv
```

Format is TSV base64.

---
# Opening the store

```ocaml
Stor.prepare_io
  Wodan.OpenExistingDevice
  block
  Wodan.standard_mount_options
>>= fun (store, gen) ->
```

or

```ocaml
{Wodan.standard_mount_options with
  fast_scan = fast_scan;
  cache_size = cache_size}
```

---
# Accessing the store

```ocaml
Store.lookup store key
>>= function
	|Some counter ->
		let c = Int64.of_string
			@@ Store.string_of_value counter in
		let c = Int64.succ c in
		Store.insert store key
			@@ Store.value_of_string @@ Int64.to_string c
		>>= fun () ->
		Lwt.return c
	| None ->
		Store.insert store key @@ Store.value_of_string "1"
		>>= fun () ->
		Lwt.return 1L
```

<small>
Note: string <-> key and string <-> value conversions are actually free.
Serialisation isn't handled and should be provided by another
library depending on your needs.
</small>

---
# Tips and tricks

- Periodic flushing
- Bulk loading, autoflush on ENOSPC
  - Flushing can free space on the disk
- Setting a default value
- Tombstones
- Autoconfiguring module parameters from an existing superblock
- Using generation numbers in distributed settings

---
# Wodan-Irmin

…

---
# What’s next?

- Upstreaming block extensions
  - Discard, barriers
- Performance work
  - Compete with the Rust implementation
- Correctness work
  - Add checked addition and substraction (expose from the OCaml runtime)
  - Better randomized testing
  - Get fuzzing fast again
  - Test multiple Lwt threads
- Releasing
  - core and unix first, then wodan-irmin when dependencies and interfaces have stabilized

---
class: middle

# Go play!

* https://github.com/g2p/wodan
* https://github.com/mato/camel-service (counter-wodan unikernel)

Build on this, and remember to persist.

---
class: middle

```
                     ,,__
           ..  ..   / o._)                   .---.
          /--'/--\  \-'||        .----.    .'     '.
         /        \_/ / |      .'      '..'         '-.
       .'\  \__\  __.'.'     .'          ì-._
         )\ |  )\ |      _.'
        // \\ // \\
       ||_  \\|_  \\_
   mrf '--' '--'' '--'

       12 camels served!
```
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
    <style>
      .remark-slide-content { font-size: 26px; }
      .remark-slide-content h1 { font-size: 65px; }
      .remark-slide-content h2 { font-size: 55px; }
      .remark-code { font-size: 22px; }
    </style>
  </body>
</html>

